#!/bin/bash

# _______           _        _______  _______  ______   _        _______
# (  ____ \|\     /|( (    /|(  ____ \(  ____ \(  ___ \ ( \      (  ____ \
# | (    \/| )   ( ||  \  ( || (    \/| (    \/| (   ) )| (      | (    \/
# | (__    | |   | ||   \ | || |      | (__    | (__/ / | |      | (__
# |  __)   | |   | || (\ \) || |      |  __)   |  __ (  | |      |  __)
# | (      | |   | || | \   || |      | (      | (  \ \ | |      | (
# | )      | (___) || )  \  || (____/\| (____/\| )___) )| (____/\| (____/\
# |/       (_______)|/    )_)(_______/(_______/|/ \___/ (_______/(_______/

# Written by: @Funilrys, Nissar Chababy <contact at funilrys dot com>
# Github : https://github.com/funilrys/funceble

################################ Contributors ##################################
# - @mitchellkrogza, Mitchell Krog <mitchellkrog@gmail.com>
#     - badreferslist: used along the construction of this script :)
#           @Source: https://git.io/vQPz8
#     - Idea of implementation of a timeout for whois
#           @Source: https://git.io/vQPz0
# - @PromoFaux, Adam Warner <adamw@rner.email> with Pi-Hole <https://pi-hole.net>
#     - Their blocking list is just awesome to test this script :)
# - @WaLLy3K <github@firebog.net>
#     - Idea of implementation of execution time
#           @Source: https://git.io/vQPzg
################################################################################


################################# Temporary ####################################&&
# Path to temporary file
whoIs="/var/tmp/whois.$$"
################################################################################
################################### Files ######################################
# IANA Root Zone Database file.
# The file is a dump of the extensions this script can accept.
# For update use: `tool --iana`
# Source: https://www.iana.org/domains/root/db
ianaDB="iana-domains-db"
################################################################################
###############################  Text Format ###################################
# Bold
bold=$(tput bold)

# Cyan Color
cyan=$(tput setaf 6)

# Magenta Color
magenta=$(tput setaf 5)

# Disable formating
normal=$(tput sgr0)

# Red Color
red=$(tput setaf 1)

# White Color
white=$(tput setaf 7)

################################################################################
################################## Status ######################################
# Down domain status
downStatus="INACTIVE"

# Invalid domain status
invalidStatus="INVALID"

# Valid domain status
upStatus="ACTIVE"
################################################################################
############################## Default Values ##################################
# Current Date
currentDate=$(date)

# IP for host file
customIP='0.0.0.0'

# Generate debug file under log
# DO NOT USE THIS IF YOU DON'T KNOW HOW TO DEBUG FROM OUTPUTTED FILE
debugUnknown=false

# Date if we append it to file
fileNameDate=_${currentDate// /_}

# Activate/Desactivate the generation of hosts file
generateHosts=false

# Link to script
linkScript="https://github.com/funilrys/funceble"

# If noFiles=true, We don't any results files ==> Not applied to hosts file
noFiles=false

# Number of domain which returns inactive
numberOfDown=0

# Number of domain which returns invalid
numberOfInvalid=0

# Number of domain tested
numberOfTested=0

# Number of active
numberOfUp=0

# Output less data
outputLess=false

# Output logs
outputLogs=true

# Output unified file
outputUnified=true

# If set to true, we don't print anything
quiet=false

# Regex to match
regexCurrentDir='%%currentDir%%'

# IPv4 match
regexIPv4='(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'

# HTTP Status code timeout
secondsBeforeHTTPTimeout=5

# Default seconds before timeout
secondsBeforeTimeout=30

# Show/hide execution time
showExecutionTime=false

# Show/hide percentage
showPercentage=true

# If set to false, we generate only one file with the results
splitFiles=false

# Version number
versionNumber='dev-1.4.0+12'

# IANA whois server. The following is there to give use the whois
# host we have to call to get a (valid) response.
# Note: Whois Server are different for each extension.
whoisServer="whois.iana.org"
################################################################################
################################## Outputs #####################################
# Defaut name for hosts file
hostsDefault='hosts'

# Output directory.
# Auto updated with `tool -i`
# DO NOT FORGET '/' AT THE END
outputDir='%%currentDir%%/output/'

# hosts directory
hostsDir=${outputDir}hosts/

# INACTIVE hosts directory
downHostsDir=${hostsDir}INACTIVE/

# ACTIVE hosts directory
upHostsDir=${hostsDir}ACTIVE/

# INVALID hosts directory
invalidHostsDir=${hostsDir}INVALID/

# Output of log
logOutput=${outputDir}'logs/'

# Whois output
whoisLogOutput=${logOutput}whois/

# Date output
dateLogOutput=${logOutput}dateFormat/

# Percentages output
percentageLogOutput=${logOutput}percentage/

# Output of execution Time log
executionLog=${logOutput}execution.log

# Ouput of no referer log
noRefererLogOutput=${logOutput}noReferer/

# Output of inactive domain
outputDownHost=${downHostsDir}${hostsDefault}

# Output of active domain
outputUpHost=${upHostsDir}${hostsDefault}

# Output of invalid domain
outputInvalidHost=${invalidHostsDir}${hostsDefault}

# Output of unified results
outputUnifiedResult=${outputDir}result.txt

# Output of valid results
outputUpResult=${outputDir}splited/active.txt

# Output of invalid results
outputInvalidResult=${outputDir}splited/invalid.txt

# Output of error results
outputDownResult=${outputDir}splited/inactive.txt

# Output of persentage log
outputPercentageLog=${percentageLogOutput}percentage.txt
################################################################################

# _______           _        _______ __________________ _______  _        _______
# (  ____ \|\     /|( (    /|(  ____ \\__   __/\__   __/(  ___  )( (    /|(  ____ \
# | (    \/| )   ( ||  \  ( || (    \/   ) (      ) (   | (   ) ||  \  ( || (    \/
# | (__    | |   | ||   \ | || |         | |      | |   | |   | ||   \ | || (_____
# |  __)   | |   | || (\ \) || |         | |      | |   | |   | || (\ \) |(_____  )
# | (      | |   | || | \   || |         | |      | |   | |   | || | \   |      ) |
# | )      | (___) || )  \  || (____/\   | |   ___) (___| (___) || )  \  |/\____) |
# |/       (_______)|/    )_)(_______/   )_(   \_______/(_______)|/    )_)\_______)

############################### Before Header ##################################
# Used to print some infomations before the header dataoutputDownResult comes.
#
# @CalledBy getReferer
################################################################################
beforeHeader(){
    # We get the file we're gonna print into
    # file <string>
    local file="${1}"
    
    if [[ ! -f "${file}" ]]
    then
        # If does not exist we add informations about funceble and the Date
        # of the generation of the file.
        printf "# File generated with %s\n" "${linkScript}" > ${file}
        printf "# Date of generation: %s\n" "${currentDate}" >> ${file}
        printf "\n" >> ${file}
    fi
}

############################### Print Header ###################################
# Used to print header
# if quiet=false it's printing in file
#
# @CalledBy getReferer
################################################################################
printHeader()
{
    # type <string>
    local type=${1}
    
    if [[ ${type} == 'Invalid' ]]
    then
        # Generation of header for invalid (On screen)
        printf "\n%-100s %-17s %-10s %-8s\n" "Domain" "Status" "Source"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------"
    elif [[ ${type} == 'Invalid_File' ]]
    then
        # Generation of header for invalid.txt
        printf "\n%-100s %-17s %-10s %-8s\n" "Domain" "Status" "Source" "Analyse Date"
        echo "---------------------------------------------------------------------------------------------------- ----------- ---------- ----------------------------"
    elif [[ ${type} == 'Down' ]]
    then
        # Generation of header for inactive (On screen)
        printf "\n%-100s %-35s %-17s %10s %-20s\n" "Domain" "WHOIS Server" "Status" "Source"
        echo "---------------------------------------------------------------------------------------------------- ----------------------------------- ----------- ----------"
    elif [[ ${type} == 'Down_File' ]]
    then
        # Generation of header for inactive.txt
        printf "\n%-100s %-35s %-17s %10s %-20s\n" "Domain" "WHOIS Server" "Status" "Source" "Analyse Date"
        echo "---------------------------------------------------------------------------------------------------- ----------------------------------- ----------- ---------- ----------------------------"
    elif [[ ${type} == 'Up' ]]
    then
        # Generation of header for valid (On screen)
        printf "\n%-100s %-17s %-17s %-10s %-20s\n" "Domain" "Status" "Expiration Date" "Source"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------------- ----------"
    elif [[ ${type} == 'Up_File' ]]
    then
        # Generation of header for valid.txt
        printf "\n%-100s %-17s %-17s %-10s %-20s\n" "Domain" "Status" "Expiration Date" "Source" "Analyse Date"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------------- ---------- -------------------------------"
    elif [[ ${type} == 'Generic' ]]
    then
        # Generation of header (On screen)
        printf "\n%-100s %-11s %-17s %-10s %-10s\n" "Domain" "Status" "Expiration Date" "Source" "HTTP Code"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------------- ---------- ----------"
    elif [[ ${type} == 'Generic_File' ]]
    then
        # Generation of header (On file)
        printf "\n%-100s %-11s %-17s %-10s %-10s %-20s\n" "Domain" "Status" "Expiration Date" "Source" "HTTP Code" "Analyse Date"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------------- ---------- ---------- -------------------------------"
    elif [[ ${type} == 'Less' ]]
    then
        # Generation of header (On screen)
        printf "\n%-100s %-11s %-10s\n" "Domain" "Status" "Source"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------"
    elif [[ ${type} == 'Less_File' ]]
    then
        # Generation of header (On file)
        printf "\n%-100s %-11s %-10s\n" "Domain" "Status" "Source"
        echo "---------------------------------------------------------------------------------------------------- ----------- ----------"
    elif [[ ${type} == 'Percentage' ]]
    then
        # Generation of header
        printf "\n%-11s %-12s %-12s\n" "Status" "Percentage" "Numbers"
        echo "----------- ------------ -------------"
    fi
}

################################# Prints #######################################
# Come with printHeader(). In charge to print/input generated data.
#
# @CalledBy getReferer
################################################################################
prints()
{
    # type <string>
    local type=${1}
    
    # We use the current full date as Analyse Date
    local dateAn=$(date)
    
    if [[ ${type} == 'Invalid' ]]
    then
        # Print invalid data on screen
        printf "%-100s %-17s %-8s\n" "${2}" "${invalidStatus}" "${3}"
    elif [[ ${type} == 'Invalid_File' ]]
    then
        # Print data for invalid.txt
        printf "%-100s %-17s %-8s %-8s\n" "${2}" "${invalidStatus}" "${3}" "${dateAn}"
    elif [[ ${type} == 'Down' ]]
    then
        # Print Down data on screen
        printf "%-100s %-35s %-17s %8s\n" "${2}" "${3}" "${downStatus}" "${4}"
    elif [[ ${type} == 'Down_File' ]]
    then
        # Print data for inactive.txt
        printf "%-100s %-35s %-17s %8s %-20s\n" "${2}" "${3}" "${downStatus}" "${4}" "${dateAn}"
    elif [[ ${type} == 'Up' ]]
    then
        # Print valid data on screen
        printf "%-100s %-17s %-17s %-8s\n" "${2}" "${upStatus}" "${3}" "${4}"
    elif [[ ${type} == 'Up_File' ]]
    then
        # Print data for valid.txt
        printf "%-100s %-17s %-17s %-8s %-20s\n" "${2}" "${upStatus}" "${3}" "${4}" "${dateAn}"
    elif [[ ${type} == 'Generic' ]]
    then
        # Print data
        printf "%-100s %-11s %-17s %-10s %-10s\n" "${2}" "${3}" "${4}" "${5}" "${httpCode}"
    elif [[ ${type} == 'Generic_File' ]]
    then
        # Print data
        printf "%-100s %-11s %-17s %-10s %-10s %-20s\n" "${2}" "${3}" "${4}" "${5}" "${httpCode}" "${dateAn}"
    elif [[ ${type} == 'FullHosts' ]]
    then
        # Print host file
        printf "%s %s\n" "${customIP}" "${2}"
    elif [[ ${type} == 'Less' ]]
    then
        # Print data
        printf "%-100s %-11s %-10s\n" "${2}" "${3}" "${4}"
    elif [[ ${type} == 'Less_File' ]]
    then
        # Print data
        printf "%-100s %-11s %-10s\n" "${2}" "${3}" "${4}"
    elif [[ ${type} == 'Percentage' ]]
    then
        # We calcul the results
        percentage 'result' 'act'
        percentage 'result' 'ina'
        percentage 'result' 'inv'
        
        # We print data
        printf "%-11s %-12s %-12s\n"  "ACTIVE" "${percentageOfActive}%" "${numberOfUp}"
        printf "%-11s %-12s %-12s\n"  "INACTIVE" "${percentageOfInactive}%" "${numberOfDown}"
        printf "%-11s %-12s %-12s\n"  "INVALID" "${percentageOfInvalid}%" "${numberOfInvalid}"
    fi
}


################################### Timeout ####################################
# In charge to initiate a timeout for commands
#
# @CalledBy timeout, getExpirationDate
################################################################################
timeout (){
    # type <int|string>
    time=${1}
    
    # Create the temporary file
    touch ${whoIs}
    
    # start the command in a subshell in order to avoid problem with pipes
    command="/bin/bash -c \"${2}\""
    
    expect -c "set echo \"-noecho\"; set  timeout ${time}; spawn -noecho ${command}; expect timeout { exit 1 } eof { exit 0 }"
}

############################# Generate Hosts File ##############################
# In charge to print data into hosts file
#
# @CalledBy generateInvalidFile, generateErrorFile, generateValidFile
################################################################################
generateHostsFile()
{
    # type <string>
    local type="${1}"
    
    if [[ ${generateHosts} == true ]]
    then
        if [[ ${type} == 'inactive' ]]
        then
            # We print / create the inactive file
            beforeHeader ${outputDownHost}
            prints 'FullHosts' "${domain}" >> ${outputDownHost}
        elif [[ ${type} == 'active' ]]
        then
            # We print / create active file
            beforeHeader ${outputUpHost}
            prints 'FullHosts' "${domain}" >> ${outputUpHost}
        elif [[ ${type} == 'invalid' ]]
        then
            # We print / create invalid file
            ((numberOfInvalid=${numberOfInvalid}+1))
            beforeHeader ${outputInvalidHost}
            prints 'FullHosts' "${domain}" >> ${outputInvalidHost}
        fi
    fi
}

########################### Generate Unified File ##############################
# In charge to print data into result.txt
#
# @CalledBy generateInvalidFile,generateErrorFile,generateValidFile
################################################################################
generateUnifiedFile()
{
    # type <string>
    local type=${1}
    # status <string>
    local status=${2}
    # expdate <string>
    local expdate=${3}
    
    if [[ ${outputUnified} == true ]]
    then
        if [[ -f ${outputUnifiedResult} ]]
        then
            if [[ ${outputLess} == true ]]
            then
                # We save the domain and his data to the unified file
                prints "Less_File" "${domain}" "${status}" "${type}" >> ${outputUnifiedResult}
            else
                # We save the domain and his data to the unified file
                prints "Generic_File" "${domain}" "${status}" "${expdate}" "${type}" >> ${outputUnifiedResult}
            fi
        else
            if [[ ${outputLess} == true ]]
            then
                # We create header into and in between, create the file
                beforeHeader ${outputUnifiedResult}
                printHeader "Less_File" >> ${outputUnifiedResult}
                # We save the domain and his data to the unified file
                prints "Less_File" "${domain}" "${status}" "${type}" >> ${outputUnifiedResult}
            else
                # We create header into and in between, create the file
                beforeHeader ${outputUnifiedResult}
                printHeader "Generic_File" >> ${outputUnifiedResult}
                # We save the domain and his data to the unified file
                prints "Generic_File" "${domain}" "${status}" "${expdate}" "${type}" >> ${outputUnifiedResult}
            fi
        fi
    fi
}

############################### Generate Invalid File ##########################
# In charge to print data into invalid.txt
#
# @CalledBy errorHandle
################################################################################
generateInvalidFile()
{
    # type <string>
    local type=${1}
    
    # We generate the host file
    generateHostsFile 'invalid'
    percentage 'counter' 'inv'
    
    if [[ ${noFiles} == false && ${splitFiles} == true ]]
    then
        if [[ -f ${outputInvalidResult} ]]
        then
            if [[ ${outputLess} == true ]]
            then
                # We save the domain and his data
                prints "Less_File" "${domain}" "${invalidStatus}" "${type}" >> ${outputInvalidResult}
            else
                # We save the domain and his data
                prints "Invalid_File" "${domain}" "${type}" >> ${outputInvalidResult}
            fi
        else
            if [[ ${outputLess} == true ]]
            then
                # We create header into and in between, create the file
                beforeHeader ${outputInvalidResult}
                printHeader "Less_File"  >> ${outputInvalidResult}
                # We save the domain and his data
                prints "Less_File" "${domain}" "${invalidStatus}" "${type}"  >> ${outputInvalidResult}
            else
                # We create header into and in between, create the file
                beforeHeader ${outputInvalidResult}
                printHeader 'Invalid_File' >> ${outputInvalidResult}
                # We save the domain and his data
                prints "Invalid_File" "${domain}" "${type}" >> ${outputInvalidResult}
            fi
        fi
    elif [[ ${noFiles} == false ]]
    then
        # We generate the unified file
        generateUnifiedFile "${type}" "${invalidStatus}" "Unknown"
    fi
}

################################# Generate Error File ##########################
# In charge to print data into invalid.txt
#
# @CalledBy errorHandle
################################################################################
generateErrorFile()
{
    # type <string>
    local type=${1}
    
    # We generate the host file
    generateHostsFile 'inactive'
    
    percentage 'counter' 'ina'
    
    if [[ ${noFiles} == false && ${splitFiles} == true ]]
    then
        if [[ ${referer} == '' ]]
        then
            # We assign "Not Found" to prevent empty column in files
            referer='Not Found'
        fi
        
        if [[ -f ${outputDownResult} ]]
        then
            # We save the domain and his data
            prints "Down_File" "${domain}" "${referer}" "${type}" >> ${outputDownResult}
        else
            # We create header into and in between, create the file
            beforeHeader ${outputDownResult}
            printHeader "Down_File" >> ${outputDownResult}
            # We save the domain and his data
            prints "Down_File"  "${domain}" "${referer}" "${type}" >> ${outputDownResult}
        fi
    elif [[ ${noFiles} == false ]]
    then
        # We generate the unified files
        generateUnifiedFile "${type}" "${downStatus}" "Unknown"
    fi
}

############################ Generate Valid File ###############################
# In charge to print data into invalid.txt
#
# @CalledBy getReferer, errorHandle
################################################################################
generateValidFile(){
    # We get the expiration date
    # exp <string>
    local exp=${1}
    # type <string>
    local type=${2}
    
    # If empty, we change the data of ${exp}
    if [[ ${exp} == '' ]]
    then
        exp='Unknown'
    fi
    
    # If ${quiet} != false, we don't print anything
    if [[ ${quiet} == false ]]
    then
        if [[ ${outputLess} == true ]]
        then
            # We save domain and its data
            prints "Less" "${domain}" "${upStatus}" "${type}"
        else
            # We print domain and its data
            prints "Generic" "${domain}" "${upStatus}" "${exp}" "${type}"
        fi
    fi
    
    # we generate the host file
    generateHostsFile 'active'
    
    percentage 'counter' 'act'
    
    # We execute this only if ${noFiles} == false
    if [[ ${noFiles} == false && ${splitFiles} == true ]]
    then
        if [[ -f  ${outputUpResult} ]]
        then
            if [[ ${outputLess} == true ]]
            then
                # We save domain and its data
                prints "Less_File" "${domain}" "${upStatus}" "${type}"  >> ${outputUpResult}
            else
                # We save domain and its data
                prints "Up_File" "${domain}" "${exp}" "${type}" >> ${outputUpResult}
            fi
        else
            if [[ ${outputLess} == true ]]
            then
                # We create a file and add header
                beforeHeader ${outputUpResult}
                printHeader "Less_File"  >> ${outputUpResult}
                # We add domain and its data to file
                prints "Less_File" "${domain}" "${upStatus}" "${type}"  >> ${outputUpResult}
            else
                # We create a file and add header
                beforeHeader ${outputUpResult}
                printHeader 'Up_File' >> ${outputUpResult}
                
                # We add domain and its data to file
                prints "Up_File" "${domain}" "${exp}" "${type}" >> ${outputUpResult}
            fi
        fi
    elif [[ ${noFiles} == false ]]
    then
        # We generate the unified file
        generateUnifiedFile "${type}" "${upStatus}" "${exp}"
    fi
}

############################## Error Handle ####################################
# Used to return issue status and issue url
#
# @CalledBy getReferer
################################################################################
errorHandle()
{
    # We get/save the type
    # type <string>
    local type=${1}
    # We create a variable to catch the case that domain don't pass lslookup
    local issueStatus=''
    
    # We set the current type
    sourceType="NSLOOKUP"
    
    # We save output of nslookup
    local lookup=$(nslookup ${domain})
    regexNxDomain='NXDOMAIN'
    
    if [[ ${lookup} =~ ${regexNxDomain} ]]
    then
        # If domain is down
        issueStatus='Unknown'
    elif [[ ${issueStatus} == '' ]]
    then
        # If domain is up, We generate the valid/unified file
        generateValidFile "Unknown" "${sourceType}"
        return 1
    fi
    
    if [[  ${issueStatus} == 'Unknown' && ${type} == 'Down' || ${type} == 'Invalid' || ${type} != 'Up' ]]
    then
        # We assign the status
        local status="${downStatus}"
        
        # We generate the error/unified file
        generateErrorFile "${sourceType}"
    fi
    
    # If quiet != false, we don't print anything
    if [[ ${quiet} == false ]]
    then
        if [[ ${outputLess} == true ]]
        then
            # We print data to screen
            prints "Less" "${domain}" "${status}" "${sourceType}"
        else
            # We print data to screen
            prints "Generic" "${domain}" "${status}" "Unknown" "${sourceType}"
        fi
    fi
}

############################## No Referers Log #################################
# Used to generate the logs
#
# @CalledBy getReferer
################################################################################
noRefererLog(){
    if [[ ${outputLogs} == true ]]
    then
        # We save the output of the captured date into log directory
        printf "=%.0s" {1..100} >> ${noRefererLogOutput}.${domainExtension}
        printf "\nNo referer found for: %s domains\n" "${domainExtension}" >> ${noRefererLogOutput}.${domainExtension}
        printf "Tested domain: %s\n" "${initialDomain}" >> ${noRefererLogOutput}.${domainExtension}
        printf "=%.0s" {1..100} >> ${noRefererLogOutput}.${domainExtension}
        printf "\n" >> ${noRefererLogOutput}.${domainExtension}
    fi
}

############################### Get Referer ####################################
# Used to generate the report issue url
#
# @CalledBy getExpirationDate
################################################################################
getReferer(){
    # initialDomain <string>
    local initialDomain="${1}"
    
    if [[ ! "${initialDomain}" =~ ${regexIPv4} ]]
    then
        # We get the extension of the given domain
        domainExtension=${initialDomain##*.}
        # We get the list of allowed extensions
        validExtension=$(cat ${ianaDB})
        
        # We check if the given domain extension is in our database file
        if [[ ${validExtension} =~ ${domainExtension} ]]
        then
            # We initiate this variable in order to know if ${domainExtension} pass
            # The cases
            notSupported=true
            
            # Special cases domains which don't have their whois server
            # registered to IANA.
            # cf. https://github.com/funilrys/funceble/issues?q=is%3Aissue+Not+Found+is%3Aclosed
            case ${domainExtension} in
                ga)
                    # We assign the domain WHOIS referer server
                    referer="whois.my.ga"
                    # The Following is used to stop the execution of getExpirationDate
                    # in case the domain is not valid.
                    notSupported=false
                ;;
                za)
                    # We assign the domain WHOIS referer server
                    referer="whois.registry.net.za"
                    # The Following is used to stop the execution of getExpirationDate
                    # in case the domain is not valid.
                    notSupported=false
                ;;
                bz)
                    # We assign the domain WHOIS referer server
                    referer="whois.afilias-grs.info"
                    # The Following is used to stop the execution of getExpirationDate
                    # in case the domain is not valid.
                    notSupported=false
                ;;
            esac
            
            if [[ ${notSupported} == true ]]
            then
                # We get the host to call.
                # If extension have a host assigned, it's written if format
                # refer: whois.hello.world for example
                referer=$(whois -h "${whoisServer}" "${initialDomain}" | awk '/refer/{print $NF}')
                
                # regex to pass to have a valid referer
                regexWhois='(.*)whois(.*)'
                
                # We check if the format is valid
                if [[ ${referer} =~ ${regexWhois} ]]
                then
                    # The Following is used to stop the execution of getExpirationDate
                    # in case the domain is not valid.
                    notSupported=false
                else
                    # We empty the referer variable
                    referer=''
                    
                    # We log the issue
                    noRefererLog
                    
                    # We handle error & check if server is up
                    errorHandle 'Down'
                fi
            fi
        else
            # We handle error & check if server is up
            notSupported=true
            errorHandle 'Invalid'
        fi
    else
        # We handle error & check if server is up
        notSupported=true
        errorHandle 'Invalid'
    fi
}

################################## Whois Log ###################################
# Used to generate the logs
#
# @CalledBy getExpirationDate
################################################################################
whoisLog(){
    if [[ ${outputLogs} == true ]]
    then
        # We save the output of whois into log directory
        printf "=%.0s" {1..100} >> ${whoisLogOutput}${referer}
        printf "\n" >> ${whoisLogOutput}${referer}
        cat ${whoIs} >> ${whoisLogOutput}${referer}
        printf "\n" >> ${whoisLogOutput}${referer}
        printf "=%.0s" {1..100} >> ${whoisLogOutput}${referer}
        printf "\n" >> ${whoisLogOutput}${referer}
    fi
}

############################## Date Format Log #################################
# Used to generate the logs
#
# @CalledBy formatDate
################################################################################
dateFormatlog(){
    if [[ ${outputLogs} == true ]]
    then
        # We save the output of the captured date into log directory
        printf "=%.0s" {1..100} >> ${dateLogOutput}${referer}
        printf "\nExpiration Date:%s\n" "${expirationDate}" >> ${dateLogOutput}${referer}
        printf "=%.0s" {1..100} >> ${dateLogOutput}${referer}
        printf "\n" >> ${dateLogOutput}${referer}
    fi
}

############################### Get HTTP Code ##################################
# Used to get the HTTP code of the requested domain or IP
#
# @CalledBy getExpirationDate
################################################################################
getHTTPCode(){
    # We get the HTTP header
    httpCode=$(timeout ${secondsBeforeHTTPTimeout} "wget --spider -S "${domain}:80" 2>&1 | grep "HTTP/"")
    
    # We format it to get the current code
    httpCode=$(echo ${httpCode} | tr -cd '[[:digit:]]' | head -c5 | tail -c3)
    
    # In case of timeout we print Unknown
    if [[ ${httpCode} == '' ]]
    then
        httpCode='Unknown'
    fi
}

####################### Get (Domain) Expiration Date ###########################
# Used to get the expiration date of a given domain.
#
# @CalledBy None
################################################################################
getExpirationDate(){
    # domain <string>
    # Domain given by user
    domain="$(echo ${1} |awk '{print tolower($0)}')"
    
    # We get the HTTP code
    getHTTPCode
    
    # We get the whois server referenced for the given domain
    getReferer ${domain}
    
    # Ensure that it's supported and not empty
    if [[ ! "${initialDomain}" =~ ${regexIPv4} && ${notSupported} == false && ${domain} != "" && ${referer} != "" ]]
    then
        # We call the whois server and save the result into ${whoIs}
        # cf. Default Values Section
        timeout ${secondsBeforeTimeout} "whois -h ${referer} ${domain} > ${whoIs}"
        
        # We get the content of the previously saved file
        local content=$(cat ${whoIs})
        
        # Here's a list of words the ${content} have to match to get the
        # expiration date from the whois record of domain
        local toMatch=('expire:' 'expire on:' 'Expiry Date:' 'free-date' 'expires:' 'Expiration date:' 'Expiry date:' 'Expire Date:' 'renewal date:' 'Expires:' 'validity:' 'Expiration Date             :' 'Expiry :' 'expires at:' 'domain_datebilleduntil:' 'Data de expiração \/ Expiration Date \(dd\/mm\/yyyy\):' 'Fecha de expiración \(Expiration date\):' '\[Expires on\]' 'Record expires on' 'status:      OK-UNTIL' 'renewal:' 'expires............:' 'expire-date:' 'Exp date:' 'Valid-date' 'Expires On:' 'Fecha de vencimiento:' 'Expiration:.........' 'Fecha de Vencimiento:' 'Registry Expiry Date:' 'Expires on..............:' 'Expiration Time:' 'Expiration Date:' 'Expired:' "Date d'expiration:")
        
        for i in ${!toMatch[*]}
        do
            if [[ ${content} =~ ${toMatch[${i}]} ]]
            then
                # We get the expiration date
                if [[ ${toMatch[${i}]} == '\[Expires on\]' ]]
                then
                    expirationDate=$(cat ${whoIs} | awk "/${toMatch[${i}]}/{print $NC}" | sed "s/\] /]:/")
                elif [[ ${toMatch[${i}]} == 'Record expires on' ]]
                then
                    expirationDate=$(cat ${whoIs} | awk "/${toMatch[${i}]}/{print $NC}" | sed "s/on/on:/" | sed "s/\s(YYYY-MM-DD)//")
                else
                    expirationDate=$(cat ${whoIs} | awk "/${toMatch[${i}]}/{print $NC}")
                fi
                
                expirationDate=${expirationDate#*:}
                expirationDate=$(echo -e "${expirationDate}" | sed -e 's/^[[:space:]]*//')
                
                # Regex to pass in order to be reconized as a date
                regexNumber='[0-9]'
                if [[ ${expirationDate} =~ ${regexNumber} ]]
                then
                    # If it contain numbers, we format it
                    formatDate
                    
                    # We set the current type
                    sourceType="WHOIS"
                    
                    # We generate valid/unified file
                    generateValidFile "${expirationDate}" "${sourceType}"
                    return 1
                elif [[ ${expirationDate} == '' && ${debugUnknown} == true ]]
                then
                    # In case expiration Date is empty we save the record so we
                    # can debug it.
                    # In case this happen please report issue to
                    # https://github.com/funilrys/funceble/issues/new
                    # So it can be fixed for everyone who use this script
                    #
                    # You can find the logs under output/logs/whois/
                    # or with the command `ls output/logs/whois/*`
                    whoisLog
                fi
            elif [[ ${i} == $(( ${#toMatch[@]} - 1)) ]]
            then
                if [[ ${debugUnknown} == true ]]
                then
                    # generate whois log file
                    whoisLog
                fi
                # We handle error & check if server is up
                errorHandle 'Down'
            fi
        done
    fi
}

################################ Date to Lower #################################
# Used to convert date to lower case
#
# @CalledBy formatDate
################################################################################
dateToLower(){
    expirationDate=$(echo "${expirationDate}" | awk '{print tolower($0)}')
}

############################# Get Month In English #############################
# Used to convert month from numeric to alphabetic
#
# @CalledBy formatDate
################################################################################
convertOrShortenMonth(){
    # numericMonth <int>
    local numericMonth=${1}
    
    case ${numericMonth} in
        1|01|January)
            month='jan'
        ;;
        2|02|February)
            month='feb'
        ;;
        3|03|March)
            month='mar'
        ;;
        4|04|April)
            month='apr'
        ;;
        5|05|May)
            month='may'
        ;;
        6|06|June)
            month='jun'
        ;;
        7|07|July)
            month='jul'
        ;;
        8|08|August)
            month='aug'
        ;;
        9|09|September)
            month='sep'
        ;;
        10|October)
            month='oct'
        ;;
        11|November)
            month='nov'
        ;;
        12|December)
            month='dec'
        ;;
        *)
            month='0'
        ;;
    esac
}

############################# Convert 1 to 2 Digits ##########################
# Used to convert one digit to two Digits numbers
# e.g -> 1 ==> 01
#
# @CalledBy formatDate
################################################################################
convert1To2digits(){
    # number <int>
    local number="${1}"
    # monthOrDay <strin>
    local monthOrDay="${2}"
    
    # We set the valid 1 digit number
    local validNumber=('1' '2' '3' '4' '5' '6' '7' '8' '9')
    
    # The difig we append to those 1 digit number
    local null='0'
    
    for i in ${!validNumber[*]}
    do
        # If the number is in ${validNumber}
        if [[ ${number} == ${validNumber[${i}]} ]]
        then
            case "${monthOrDay}" in
                month)
                    # If we need the month, we save the 2 digit into mouth
                    month=${null}${number}
                    break
                ;;
                day)
                    # If we need the day, we save the 2 digit into day
                    day=${null}${number}
                    break
                ;;
            esac
        fi
    done
}

################################ Format Date ###################################
# Used to format date. We have to work with multiple date format from WHOIS
# records so this function is in charge to create an unified format.
#
# @CalledBy getExpirationDate
################################################################################
formatDate()
{
    # Date in format: 02-jan-2017
    local regex1='[0-9]{2}-[a-z]{3}-[0-9]{4}'
    # Date in format: 02.01.2017 // Month: jan
    local regex2='[0-9]{2}\.[0-9]{2}\.[0-9]{4}$'
    # Date in format: 02/01/2017 // Month: jan
    local regex3='[0-9]{2}\/[0-9]{2}\/[0-9]{4}'
    # Date in format: 2017-01-02 // Month: jan
    local regex4='[0-9]{4}-[0-9]{2}-[0-9]{2}$'
    # Date in format: 2017.01.02 // Month: jan
    local regex5='[0-9]{4}\.[0-9]{2}\.[0-9]{2}$'
    # Date in format: 2017/01/02 // Month: jan
    local regex6='[0-9]{4}\/[0-9]{2}\/[0-9]{2}$'
    # Date in format: 2017.01.02 15:00:00
    local regex7='[0-9]{4}\.[0-9]{2}\.[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}'
    # Date in format: 20170102 15:00:00 // Month: jan
    local regex8='[0-9]{8}\s[0-9]{2}:[0-9]{2}:[0-9]{2}'
    # Date in format: 2017-01-02 15:00:00 // Month: jan
    local regex9='[0-9]{4}-[0-9]{2}-[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}'
    # Date in format: 02.01.2017 15:00:00 // Month: jan
    local regex10='[0-9]{2}\.[0-9]{2}\.[0-9]{4}\s[0-9]{2}:[0-9]{2}:[0-9]{2}'
    # Date in format: 02-Jan-2017 15:00:00 UTC
    local regex11='[0-9]{2}-[A-Z]{1}[a-z]{2}-[0-9]{4}\s[0-9]{2}:[0-9]{2}:[0-9]{2}\s[A-Z]{1}.*'
    # Date in format: 2017/01/02 01:00:00 (+0900) // Month: jan
    local regex12='[0-9]{4}\/[0-9]{2}\/[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}\s\(.*\)'
    # Date in format: 2017/01/02 01:00:00 // Month: jan
    local regex13='[0-9]{4}\/[0-9]{2}\/[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}$'
    # Date in format: Mon Jan 02 15:00:00 GMT 2017
    local regex14='[a-zA-Z]{3}\s[a-zA-Z]{3}\s[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}\s[A-Z]{3}\s[0-9]{4}'
    # Date in format: Mon Jan 02 2017
    local regex15='[a-zA-Z]{3}\s[a-zA-Z]{3}\s[0-9]{2}\s[0-9]{4}'
    # Date in format: 2017-01-02T15:00:00 // Month: jan
    local regex16='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$'
    # Date in format: 2017-01-02T15:00:00Z // Month: jan
    local regex17='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}[A-Z].*'
    # Date in format: 2017-01-02T15:00:00+0200 // Month: jan
    local regex18='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}[+-][0-9]{4}'
    # Date in format: 2017-01-02T15:00:00+0200.622265+03:00 // Month: jan
    local regex19='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9].*[+-][0-9]{2}:[0-9]{2}'
    # Date in format: 2017-01-02T15:00:00+0200.622265 // Month: jan
    local regex20='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{6}$'
    # Date in format: 2017-01-02T23:59:59.0Z // Month: jan
    local regex21='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9].*[A-Z]'
    # Date in format: 02-01-2017 // Month: jan
    local regex22='[0-9]{2}-[0-9]{2}-[0-9]{4}'
    # Date in format: 2017. 01. 02. // Month: jan
    local regex23='[0-9]{4}\.\s[0-9]{2}\.\s[0-9]{2}\.'
    # Date in format: 2017-01-02T00:00:00+13:00 // Month: jan
    local regex24='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}[+-][0-9]{2}:[0-9]{2}'
    # Date in format: 20170102 // Month: jan
    local regex25='[0-9]{8}$'
    # Date in format: 02-Jan-2017
    local regex26='[0-9]{2}-[A-Z]{1}[a-z]{2}-[0-9]{4}$'
    # Date in format: 02.1.2017 // Month: jan
    local regex27='[0-9]{2}\.[0-9]{1}\.[0-9]{4}'
    # Date in format: 02 Jan 2017
    local regex28='[0-9]\s[A-Z]{1}[a-z]{2}\s[0-9]{4}'
    # Date in format: 02-January-2017
    local regex29='[0-9]{2}-[A-Z]{1}[a-z]*-[0-9]{4}'
    # Date in format: 2017-Jan-05.
    local regex30='[0-9]{4}-[A-Z]{1}[a-z]{2}-[0-9]{2}\.'
    # Date in format: Mon Jan 02 15:00:00 2017
    local regex31='[a-zA-Z]{3}\s[a-zA-Z]{3}\s[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}\s[0-9]{4}'
    
    if [[ "${expirationDate}" =~ ${regex1} || "${expirationDate}" =~ ${regex26} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c4)
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]' | head -c3)
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    elif [[ "${expirationDate}" =~ ${regex30} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c2)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c4)
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]')
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    elif [[ "${expirationDate}" =~ ${regex29} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c4)
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]')
        
        # We convert the month
        convertOrShortenMonth "${month}"
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
    elif [[ "${expirationDate}" =~ ${regex11} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c6 | tail -c4)
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]' | head -c3)
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    elif [[ "${expirationDate}" =~ ${regex2} || "${expirationDate}" =~ ${regex3} || "${expirationDate}" =~ ${regex10} || "${expirationDate}" =~ ${regex22} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local month=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c4 | tail -c2)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c8 | tail -c4)
        
        # We convert the month
        convertOrShortenMonth "${month}"
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
    elif [[ "${expirationDate}" =~ ${regex4} || "${expirationDate}" =~ ${regex5} || "${expirationDate}" =~ ${regex6} || "${expirationDate}" =~ ${regex7} || "${expirationDate}" =~ ${regex8} || "${expirationDate}" =~ ${regex9} || "${expirationDate}" =~ ${regex12} || "${expirationDate}" =~ ${regex13} || "${expirationDate}" =~ ${regex16} || "${expirationDate}" =~ ${regex17} || "${expirationDate}" =~ ${regex18} || "${expirationDate}" =~ ${regex19} || "${expirationDate}" =~ ${regex20} || "${expirationDate}" =~ ${regex21} || "${expirationDate}" =~ ${regex23} || "${expirationDate}" =~ ${regex24} || "${expirationDate}" =~ ${regex25} ]]
    then
        # We split the date
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c4)
        local month=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c6 |tail -c2)
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c8 | tail -c2)
        
        # We convert the month
        convertOrShortenMonth "${month}"
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
    elif [[ "${expirationDate}" =~ ${regex14} || "${expirationDate}" =~ ${regex15} || "${expirationDate}" =~ ${regex31} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]' | head -c6 | tail -c3)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c4)
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    elif [[ "${expirationDate}" =~ ${regex27} ]]
    then
        # We split the date
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c2)
        local month=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c3 | tail -c1)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c4)
        
        # We convert the month
        convert1To2digits "${month}" "month"
        
        # We convert the month to alpha format
        convertOrShortenMonth "${month}"
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    elif [[ "${expirationDate}" =~ ${regex28} ]]
    then
        # We split the date
        local month=$(echo "${expirationDate}" | tr -cd '[[:alpha:]]' | head -c3)
        local year=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | tail -c4)
        local day=$(echo "${expirationDate}" | tr -cd '[[:digit:]]' | head -c4)
        
        # We get the last 2 digits of the day
        local dayEnd=$(echo "${day}" | tr -cd '[[:digit:]]' | tail -c2)
        
        # We use 20 to check if it's a 1 or 2 digts day
        # Case:
        #    2 Jan 2017
        #        Result: 2201
        #    02 Jan 2017-01
        #        Result: 0220
        # So if the last 2 digts are not 20, it's a 1 digit day
        # Hope that I don't have to update this in 100 years ! :)
        if [[ ${dayEnd} == '20' ]]
        then
            local day=$(echo "${day}" | tr -cd '[[:digit:]]' | head -c2)
        else
            local day=$(echo "${day}" | tr -cd '[[:digit:]]' | head -c1)
            
            # We convert the day
            convert1To2digits "${day}" "day"
        fi
        
        # We assign the expiration date
        expirationDate=${day}'-'${month}'-'${year}
        
        # We convert it to lower case
        dateToLower
    else
        # We log that we did'nt match the date
        dateFormatlog
    fi
}

########################### Start Execution Time ###############################
# Used to catch the execution time
#
# @CalledBy main
################################################################################
startExecutionTime()
{
    if [[ ${showExecutionTime} == true ]]
    then
        #We log the execution
        echo "Execution Time log of" $(date) >> ${executionLog}
        echo "----------------------------------------------------------------" >> ${executionLog}
        # We get execution start time
        executionStart=$(date +%s)
        # We log the start time
        printf "Start: %s\n" "${executionStart}" >> ${executionLog}
    fi
}

########################### End Execution Time ###############################
# Used to catch the execution time
#
# @CalledBy main
################################################################################
endExecutionTime()
{
    if [[ ${showExecutionTime} == true ]]
    then
        # We get execution end time
        executionEnd=$(date +%s)
        # We log end time
        printf "End: %s\n" "${executionEnd}" >> ${executionLog}
        
        # We get the difference between end and start
        timeDifference=$(( ${executionEnd} - ${executionStart} ))
        
        # We get the hours
        ((hours=${timeDifference}/3600))
        # We get the minutes
        ((minutes=(${timeDifference}%3600)/60))
        # We get the seconds
        ((seconds=${timeDifference}%60))
        
        # We display + log message
        printf "\n${magenta}Execution Time:${normal}\n" && printf "Execution Time:" >> ${executionLog}
        printf "%02d:%02d:%02d\n \n" ${hours} ${minutes} ${seconds} && printf "%02d:%02d:%02d\n \n" ${hours} ${minutes} ${seconds} >> ${executionLog}
    fi
}

################################# Percentage ###################################
# Used to increment the number of tested and number of inactive/invalid
# In between it's calculate the percentage
#
# @CalledBy main
################################################################################
percentage()
{
    # We get type of the operation to do
    # type <string>
    local type="${1}"
    # And the information to calculate (ina/inv)
    local status="${2}"
    
    if [[ ${showPercentage} == true ]]
    then
        # We increment the number of tested
        
        if [[ ${type} == 'counter' && ${status} == 'ina' ]]
        then
            # We increment the number of inactive
            ((numberOfTested=${numberOfTested}+1))
            ((numberOfDown=${numberOfDown}+1))
        elif [[ ${type} == 'counter' && ${status} == 'inv' ]]
        then
            # We increment the number of invalid
            ((numberOfTested=${numberOfTested}+1))
            ((numberOfInvalid=${numberOfInvalid}+1))
        elif [[ ${type} == 'counter' && ${status} == 'act' ]]
        then
            # We increment the number of active
            ((numberOfTested=${numberOfTested}+1))
            ((numberOfUp=${numberOfUp}+1))
        elif [[ ${type} == 'result' && ${status} == 'ina' ]]
        then
            # We calculate the percentage of inactive
            ((percentageOfInactive=${numberOfDown}*100/${numberOfTested}))
        elif [[ ${type} == 'result' && ${status} == 'inv' ]]
        then
            # We calculate the percentage of invalid
            ((percentageOfInvalid=${numberOfInvalid}*100/${numberOfTested}))
        elif [[ ${type} == 'result' && ${status} == 'act' ]]
        then
            # We calculate the percentage of active
            ((percentageOfActive=${numberOfUp}*100/${numberOfTested}))
        fi
        
        if [[ ${type} == 'results' ]]
        then
            # We calculate the sum of
            # ${percentageOfInvalid} && ${percentageOfInactive}
            ((percentageOfInvaIna=${percentageOfInvalid}+${percentageOfInactive}))
        fi
    fi
}

############################## Check Hosts File ################################
# Used to check if hosts file already exist. The main purpose of this function
# is to avoid collisions and overwritting
#
# @CalledBy Arguments Handle Section
################################################################################
checkHostsFiles()
{
    if [[ -f ${outputUpHost} || -f ${outputInvalidHost} || -f ${outputDownHost} ]]
    then
        # We append the date to the default values
        outputUpHost=${outputUpHost}${fileNameDate}
        outputInvalidHost=${outputInvalidHost}${fileNameDate}
        outputDownHost=${outputDownHost}${fileNameDate}
    fi
}
################################## Main ########################################
# Main function used to call other function
#
# @CalledBy Arguments Handle Section
################################################################################
main()
{
    startExecutionTime
    # We get the domain
    # domain <string>
    domain=${1}
    # We get the file
    # file <string>
    file=${2}
    
    if [[ "${domain}" != "" ]]
    then
        # We only print message if ${quiet} == false
        if [[ ${quiet} == false ]]
        then
            if [[ ${outputLess} == true ]]
            then
                printHeader "Less"
            else
                printHeader "Generic"
            fi
        fi
        
        # We execute the getExpirationDate function
        getExpirationDate "${domain}"
    elif [[ ${file} != "" ]]
    then
        if [[ -f "${file}" &&  -r "${file}" ]]
        then
            # We only print message if ${quiet} == false
            if [[ ${quiet} == false ]]
            then
                if [[ ${outputLess} == true ]]
                then
                    printHeader "Less"
                else
                    printHeader "Generic"
                fi
            fi
            
            # We read the list of the file and pass the domain (1 line = 1 domain)
            # to getExpirationDate
            while read domain
            do
                # In case the file contain comment or empty line we continue to
                # the next line
                case "${domain}" in
                    ''|\#*|*localhost*|local|broadcasthost)
                        continue
                    ;;
                    '127.0.0.1'*|'0.0.0.0'*)
                        domain=$(echo "${domain}"|cut -d ' ' -f2)
                    ;;
                esac
                
                # We get the expiration date and check status in between
                getExpirationDate "${domain}"
            done < ${file}
        else
            # We exit in case file don't exit or is not readable
            echo "File not found or unreadable"
            exit 0
        fi
    else
        # If domain is empty & file file don't exist we print usage
        usage
    fi
    endExecutionTime
    
    if [[ ${showPercentage} == true ]]
    then
        # We print on screen the percentage and its header
        beforeHeader ${outputPercentageLog}
        printHeader 'Percentage' && printHeader 'Percentage' > ${outputPercentageLog}
        prints 'Percentage' && prints 'Percentage' >> ${outputPercentageLog}
    fi
    
    if [[ -f wget-log ]]
    then
        rm wget* 2&> /dev/null
    fi
}

################################## Usage #######################################
# Help function
#
# @CalledBy main, Arguments Handle Section
################################################################################
usage()
{
    echo "Usage: ${0} [ -a|--all ] [ -ex|--execution ] [ --help ] [ -h ] [ -ip ] [ -q|--quiet ] [ -n|--noFiles ] [ -p|--percentage ] [ -nl|--noLogs ] [ -nu|--noUnified ] [ --split ] [ -t|--timeout ]"
    echo ""
    echo "       {[ -d domain-name.me ]} || {[ -f listOfDomainInAFile ]}"
    echo ""
    echo "  --all                      -a              Output all information on screen (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --domain                   -d              Domain to analyze"
    echo "  --file                     -f              File with a list of domains"
    echo "  --execution                -ex             Show the execution time (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --help                                     Print this screen"
    echo "                             -ip             Change the ip to print in host file (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --host                     -h              Activate the generation of hosts file (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --quiet                    -q              Activate quiet mode (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --percentage               -p              Show the percentage of the results (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --noFiles                  -n              Deactivate the production of output files (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --noLogs                   -nl             Deactivate the production of logs files in case we encounter some errors (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --noUnified                -nu             Deactivate the production of result.txt as unified result under the output directory (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --split                                    Split output files (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --timeout                  -t              Seconds before timeout (${red}${bold}Must be before ${cyan}-d${normal} ${red}${bold}or ${cyan}-f${normal})"
    echo "  --version                  -v              Show the current version of Funceble"
    echo ""
    echo "Examples:"
    echo ""
    echo "  ${0} -d helloworld.com ${bold}OR${normal} ${0} --domain=helloworld.com"
    echo "           Search if ${cyan}helloworld.com${normal} is ${bold}ACTIVE${normal} or ${bold}not${normal}"
    echo "           Print the output in screen and under the ${cyan}output${normal} directory"
    echo ""
    echo "  ${0} -f /home/helloworld/lists/badrefers.list ${bold}OR${normal} --file=/home/helloworld/lists/badrefers.list"
    echo "           Search if ${cyan}all domains${normal} under the file ${cyan}/home/helloworld/lists/badrefers.list${normal} are ${bold}ACTIVE${normal} or ${bold}not${normal}"
    echo "           Print the output in screen and under the ${cyan}output${normal} directory"
    echo ""
    echo " ${0} -h -f /home/helloworld/lists/badrefers.list ${bold}OR${normal} --file=/home/helloworld/lists/badrefers.list"
    echo "           Same as ${bold}${0} -f${normal}"
    echo "           Generate the ${cyan}hosts file${normal} under the ${cyan}output${normal} directory"
    echo ""
    echo " ${0} -q -f /home/helloworld/lists/badrefers.list ${bold}OR${normal} --file=/home/helloworld/lists/badrefers.list"
    echo "           Same as ${bold}${0} -f${normal}"
    echo "           Instead, it does not generate output on screen"
    echo ""
}


############################### Arguments Handle ###############################
# We use this part to get arguments from command line.
#
# @Requiredby All
################################################################################
if [[  ${outputDir} =~ ${regexCurrentDir} ]]
then
    # We print the following to avoid the use of this script without
    # dependencies check
    printf "${bold}${red}Please run the installation script first. \nYou can run it with: %s\n" "${cyan}${PWD}/tool -i${normal}"
    exit 0
else
    while [ "$#" -gt 0 ]; do
        case "$1" in
            # We catch if we have to print all infos on screen
            -a|-all)
                outputLess=false
                shift 1
            ;;
            
            # We catch domain
            -d)
                main "${2}" ''
                shift 2
            ;;
            
            # We catch if we show the execution time
            -ex|--execution)
                showExecutionTime=true
                quiet=false
                shift 1
            ;;
            
            # We catch file path
            -f)
                main '' "${2}"
                shift 2
            ;;
            
            # we catch if the user want to activate the creation of hosts file
            -h|--host)
                generateHosts=true
                checkHostsFiles
                shift 1
            ;;
            
            --help)
                usage
                shift 1
            ;;
            
            # We change the IP to print into the hosts file
            -ip)
                customIP="${2}"
                shift 2
            ;;
            
            # We catch if we can produce file or not
            -n|--noFiles)
                noFiles=true
                quiet=false
                shift 1
            ;;
            
            # We catch if we need to deactivate the generation of
            # output/logs/*
            -nl|--noLogs)
                outputLogs=false
                shift 1
            ;;
            
            # We catch if we need to active or deactivate the generation of
            # output/result.txt
            -nu|--noUnified)
                outputUnified=false
                shift 1
            ;;
            
            # We catch if have to show or hide the percentages
            -p|--percentage)
                showPercentage=true
                shift 1
            ;;
            
            # Activation of quiet system
            -q|--quiet)
                quiet=true
                noFiles=false
                shift 1
            ;;
            
            # We split the result into different file
            --split)
                splitFiles=true
                noFiles=false
                shift 1
            ;;
            
            # We set the seconds before timeout
            -t|--timeout)
                secondsBeforeTimeout="${2}"
                shift 2
            ;;
            
            # We catch if we have to show the version number
            -v|--version)
                echo "Current Version: ${versionNumber}"
                exit 1
            ;;
            
            # catch the domain after --domain= for example: --domain=helloworld.com
            # Will result only helloworld.com
            --domain=*)
                domainToCheck=${1#*=}
                main "${domainToCheck}" ''
                shift 1
            ;;
            
            # catch the domain after --domain= for example: --file=lustUsedInDev/badreferers.list
            # Will get the file lustUsedInDev/badreferers.list
            --file=*)
                fileToCheck=${1#*=}
                main "" "${fileToCheck}"
                shift 1
            ;;
            
            # Output if option is unknown
            -*)
                echo "Unknown option: $1" >&2
                exit 1
            ;;
            
            # Output if no option is definied
            *)
                usage
                exit 1
            ;;
        esac
    done
fi
